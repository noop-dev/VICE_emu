; vdcattr
; --------
; 2009 Errol Smith

; VDC demonstration of basic text & attributes

; Start of project: 1.6.2009

; Compiles with ACME 0.91
; # acme --cpu 6502 -f cbm -o vdcattr.prg vdcattr.tas

; Type RUN to start.

; Known bugs:

; TODO:

; Memory map:
; $0000-$03ff : (mostly) unused
; $0400-$07ff : screen
; $0801-$xxxx : code
; $xxxx-$zzzz : data
; $zzzz-$ffff : unused

; Notes:


; --- Constants

!src "..\vdc2.a"







DEBUG = 0

; - colors
color_back = $2
color_border = $0
color_text = $1
color_hilite = $2

; - keys
key_up    = $91
key_down  = $11

key_left  = $9d ; dma on
key_right = $1d ; dma off

key_enter = $0d ; save reg
key_s = $53     ; save all regs

key_space = $20 ; start test
key_g = $47     ; stop test

key_y = $59     ; increase vol
key_h = $48     ; decrease vol

key_u = $55     ; increase env
key_j = $4a     ; decrease env

key_i = $49     ; env += $10
key_k = $4b     ; env -= $10

key_o = $4f     ; save env reg
key_l = $4c     ; 


; - kernal functions
SCNKEY = $ff9f
GETIN = $ffe4           ; ret: a = 0: no keys pressed, otherwise a = ASCII code

; - hw addresses
screen = $0400          ; screen address
color = $d800           ; color ram address
vicborder = $d020       ; border color register
vicbackgnd = $d021      ; background color register
vicraster = $d012       ; raster compare register
keybuf = $0277          ; keyboard buffer
keybuflen = $c6         ; keyboard buffer byte count
sidbase = $d400         ; SID base address

; - other
rastercmp = $ff
cursor_min = $7
cursor_max = $e
dmalen = 63*312/2 ; - 1

; --- Zero page variables

; temp variables
tmp  = $23
tmp2 = $24
tmp3 = $25

; - colorram pointer
colptr = $fb
colptrh = $fc

; - temp pointer
tmpptr = $fd
tmpptrh = $fe




!ct scr ; screencode

; --- Main 

crsrx = $ec
crsry = $eb

vdcattributehi=$08


; start of program
*=$1c01
entry:
; BASIC stub: "128 SYS 7181"
!by $0b,$1c,$80,$00,$9e,$37,$31,$38,$31,$00,$00,$00


; change some default VDC values that are wrong on early kernels (like mine)
lda #$7f
ldx #0
+vdc_sta_rx

lda #$26
ldx #4
+vdc_sta_rx


; reset some registers in case they are in random settings (like graphics mode)
ldx #25
lda #$47
+vdc_sta_rx


; fill char memory with stuff

; set start address for vdc char write
lda #$00	; hi address
ldx #18
+vdc_sta_rx

lda #$00	; lo address
ldx #19
+vdc_sta_rx

; fill char with codes 0-127 repeatedly
ldx #31	;r/w register
+vdc_set_rx
ldx #10	; 10 x 128 = 16 x 80 .. 16 lines of 80 chars
fillcstart:
ldy #$00
- +vdc_sty
iny
bpl -
dex
bne fillcstart

; print the menu below the test stuff
- lda prgtxt,x
+vdc_sta
inx
bne -
- lda prgtxt+$0100,x
+vdc_sta
inx
bne -
- lda prgtxt+$0200,x
+vdc_sta
inx
bne -


; fill attr memory with different attributes for each row

; set start address for vdc char write
lda #vdcattributehi	;hi
ldx #18
+vdc_sta_rx
lda #$00	;lo
ldx #19
+vdc_sta_rx
ldx #31		;r/w register
+vdc_set_rx

; fill the main test area attributes
ldy #$00
fillastart:
ldx #5	; 5 chars at same attributes  = 5 x 16 = 80 one line at each of 16 colours
- +vdc_sty
dex
bne -
iny
bne fillastart

; fill the row of colour descriptions
ldy #$41        ;reverse grey for black
ldx #5
- +vdc_sty
dex
bne -

ldy #1
fillbstart:
ldx #5	; 5 chars at same attributes  = 5 x 16 = 80 one line at each of 16 colours
- +vdc_sty
dex
bne -
iny
cpy #$10
bne fillbstart


ldy #3
lda #$0e	;fill $300 bytes extra bytes with 'dark' white
- +vdc_sta
dex
bne -
dey
bne -


; put bright white markers in the corners
ldx #0
ldy #0

; top left
jsr vdc_setscreenxy
lda #79
+vdc_sta
jsr vdc_setattrxy
lda #$0f
+vdc_sta

; top right
ldx #79
jsr vdc_setscreenxy
lda #80
+vdc_sta
jsr vdc_setattrxy
lda #$0f
+vdc_sta

; bottom right
ldy #24
jsr vdc_setscreenxy
lda #122
+vdc_sta
jsr vdc_setattrxy
lda #$0f
+vdc_sta

; bottom left
ldx #0
jsr vdc_setscreenxy
lda #76
+vdc_sta
jsr vdc_setattrxy
lda #$0f
+vdc_sta














; put the cursor somewhere
ldx #$20
stx crsrx
ldy #$11
sty crsry
jsr vdc_setcrsrxy
; turn cursor on
lda #$40	;fast blinking cursor
ldx #10
+vdc_sta_rx





; start main menu loop

mainloop:

jsr vblankwait

jsr GETIN
; beq handlestuff

cmp #65 ; "A"
bne +
; switch attributes on/off
ldx #25
+vdc_lda_rx
eor #$40
+vdc_sta_rx
jmp handlestuff
+

cmp #66 ; "B"
bne +
; switch background cycle on/off
lda backcycle
beq bb
lda #$00
sta backcycle
lda #50
sta backcyclecount
lda #$e0
ldx #26
+vdc_sta_rx
jmp handlestuff
bb: lda #$01
sta backcycle
jmp handlestuff
+


cmp #67 ; "C"
bne +
; cycle cursor mode
ldx #10
+vdc_lda_rx
clc
adc #$20
and #$7f
+vdc_sta_rx
jmp handlestuff
+

cmp #70 ; "F"
bne +
; switch character blink/flash rate high/low
ldx #24
+vdc_lda_rx
eor #$20
+vdc_sta_rx
jmp handlestuff
+


cmp #71 ; "G"
bne +
; switch between char/graphics modes
ldx #25
+vdc_lda_rx
eor #$80
+vdc_sta_rx
jmp handlestuff
+



cmp #73 ; "I"
beq +   ; switch between interlace/non interlace modes
jmp ++
+
ldx #8
+vdc_lda_rx
and #$03
eor #$03
bne imcon

; interlace mode off, load defaults
+vdc_sta_rx
;ldx #$00
;lda #$7f
;+vdc_sta_rx     ;R0 = 127 total horizontal (default)
ldx #$04
lda #$26
+vdc_sta_rx     ;r4 = 38 total vdc rows (default)
ldx #$05
lda #$00
+vdc_sta_rx     ;r5 = 6 total vertical adjust
ldx #$06
lda #$19
+vdc_sta_rx     ;R6 = 25 rows displayed (default)
ldx #$07
lda #$20
+vdc_sta_rx     ;R7 = 32 vertical sync at 32 (default)
ldx #$09
lda #$e7
+vdc_sta_rx     ;R9 = e7 vertical char scan lines
jmp handlestuff

imcon   ;interlace mode on
+vdc_sta_rx
;ldx #$00
;lda #$80
;+vdc_sta_rx     ;R0 = 128 total horizontal
ldx #$04
lda #$40
+vdc_sta_rx     ;r4 = 64 total vdc rows
ldx #$05
lda #$06
+vdc_sta_rx     ;r5 = 6 total vertical adjust
ldx #$06
lda #$32
+vdc_sta_rx     ;R6=50 rows displayed
ldx #$07
lda #$35
+vdc_sta_rx     ;R7=58 vertical sync at 58
ldx #$09
lda #$e8
+vdc_sta_rx     ;R9=e8 vertical char scan lines
jmp handlestuff
++


cmp #82 ; "R"
bne +
; switch reverse screen on/off
ldx #24
+vdc_lda_rx
eor #$40
+vdc_sta_rx
jmp handlestuff
+


cmp #86 ; "V"
bne +
; vblank test
lda vblank
eor #$ff
sta vblank
ldx #26
lda #$e0
+vdc_sta_rx
jmp handlestuff
+


cmp #88 ; "X"
bne +
; switch x smooth test on/off
lda xsmooth
beq xx

; turn xsmooth off, reset registers
lda #$00
sta xsmooth
lda smoothdefault
sta smoothcount
lda #$00
ldx #13	;screen address low
+vdc_sta_rx
ldx #21	;attribute address low
+vdc_sta_rx
ldx #25
+vdc_lda_rx
ora #$07
+vdc_sta_rx
lda #$60
ldx #10	;turn on cursor
+vdc_sta_rx
jmp handlestuff

xx:	; xsmooth is off, turn it on
lda #$20
ldx #10	;turn off cursor
+vdc_sta_rx
lda #$ff
sta xsmoothdir
sta xsmooth
jmp handlestuff
+


cmp #89 ; "Y"
beq +
jmp upbit
+
; switch y smooth test on/off
lda ysmooth
beq yy

; turn ysmooth off, reset registers
lda smoothdefault
sta smoothcount
lda #$00
sta ysmooth
ldx #13	;screen address low
+vdc_sta_rx
ldx #12	;screen address hi
+vdc_sta_rx
ldx #21	;attribute address low
+vdc_sta_rx
lda #vdcattributehi
ldx #20
+vdc_sta_rx
ldx #24
+vdc_lda_rx
and #$f0
+vdc_sta
lda #$60
ldx #10	;turn on cursor
+vdc_sta_rx
jmp handlestuff

yy:	; ysmooth is off, turn it on
lda #$20
ldx #10	;turn off cursor
+vdc_sta_rx
ldy #$00
sty ysmoothdir
iny
sty ysmooth
jmp handlestuff
+




upbit:
cmp #145 ; up cursor
bne +
dec crsry
jsr setcrsr
jmp handlestuff
+

cmp #17 ; down cursor
bne +
inc crsry
jsr setcrsr
jmp handlestuff
+

cmp #157 ; left cursor
bne +
dec crsrx
jsr setcrsr
jmp handlestuff
+

cmp #29 ; right cursor
bne +
inc crsrx
jsr setcrsr
jmp handlestuff
+

cmp #19 ; home
bne +
lda #0
sta crsrx
sta crsry
jsr setcrsr
jmp handlestuff
+



cmp #43 ; minus
bne +
dec smoothdefault
bne minus
inc smoothdefault
minus:
jmp handlestuff
+

cmp #45 ; plus
bne +
inc smoothdefault
bpl minus
dec smoothdefault
jmp handlestuff
+


; colon - decrease background colour
cmp #58 ; :
bne +
ldx #26
+vdc_lda_rx
sec
sbc #$01
and #$0f
ora #$e0
+vdc_sta_rx
jmp handlestuff
+

; semicolon - increase background colour
cmp #59 ; ;
bne +
ldx #26
+vdc_lda_rx
clc
adc #$01
and #$0f
ora #$e0
+vdc_sta_rx
jmp handlestuff
+


cmp #27	;esc
bne +
jmp exit
+


handlestuff:

lda backcycle
beq xsmoothbit
; cycle the background
dec backcyclecount
bne +
lda #50
sta backcyclecount
lda backcycle
ldx #26
+vdc_sta_rx
inc backcycle
+

xsmoothbit:
ldx xsmooth
beq ysmoothbit

; xsmooth cycle
dec smoothcount
bne +
lda smoothdefault
sta smoothcount

lda xsmooth
lsr
lsr
lsr ; divide by 8
eor #$1f
ldx #13	;screen address low
+vdc_sta_rx
ldx #21	;attribute address low
+vdc_sta_rx

lda xsmooth
and #$07
sta tmp
ldx #25
+vdc_lda_rx
and #$f0
clc
adc tmp
+vdc_sta_rx

ldx xsmooth
lda xsmoothdir
bne xneg

inx
bne x9
ldx #$ff
stx xsmoothdir
jmp x9

xneg:
dex
bne x9
stx xsmoothdir
ldx #$01

x9:
stx xsmooth
+ ;jmp endmainloop


ysmoothbit:
lda ysmooth
bne +
jmp endmainloop
+

; ysmooth cycle
dec smoothcount
beq +
jmp yend
+
lda smoothdefault
sta smoothcount

lda ysmooth
lsr
lsr
lsr ; divide by 8
tay
ldx #0
jsr screenxy
lda tmp
ldx #13	;screen address low
+vdc_sta_rx
ldx #21	;attribute address low
+vdc_sta_rx
lda tmp2
ldx #12	;screen address high
+vdc_sta_rx
ldx #20	;attribute address high
clc
adc #vdcattributehi
+vdc_sta_rx

lda ysmooth
and #$07
sta tmp
ldx #24
+vdc_lda_rx
and #$e0
clc
adc tmp
+vdc_sta_rx

ldy ysmooth
lda ysmoothdir
bne yneg

iny
bpl y9
ldy #$7f
sty ysmoothdir
jmp y9

yneg:
dey
bne y9
sty ysmoothdir
ldy #$01

y9:
sty ysmooth

yend:

+













endmainloop:
jmp mainloop


exit:

ldx #26
lda #$f0
+vdc_sta_rx	; reset to white on black background
rts	; back to basic




; subroutines

vblankwait:

;setup for fore/back register
ldx #26
+vdc_set_rx


; wait until we are out of vblank
- lda vdc_state
and #$20
bne -

;if vblank test is on, set background colour to black
ldy vblank
beq +
+vdc_sta
+

; wait until we are in vblank
- lda vdc_state
and #$20
beq -

lda vblank	;stick the vblank colour into background if !0
beq +
+vdc_sta
+

rts


setcrsr:
ldx crsrx
ldy crsry
jsr vdc_setcrsrxy
rts


vdc_setcrsrxy:
; move the cursor to x,y (destructive to A)
jsr screenxy
lda #15		;crsr low byte
sta vdc_reg
lda tmp
+vdc_sta
lda #14		;crsr high byte
sta vdc_reg
lda tmp2
+vdc_sta
rts

vdc_setscreenxy:
; move the memory pointer to screen position x,y (destructive to A)
jsr screenxy
lda #19		;low byte
sta vdc_reg
lda tmp
+vdc_sta
lda #18		;high byte
sta vdc_reg
lda tmp2
+vdc_sta
lda #31		;r/w register
sta vdc_reg
rts

vdc_setattrxy:
; move the memory pointer to attribute position x,y (destructive to A)
jsr screenxy
lda #19		;low byte
sta vdc_reg
lda tmp
+vdc_sta
lda #18		;high byte
sta vdc_reg
lda tmp2
clc
adc #vdcattributehi
+vdc_sta
lda #31		;r/w register
sta vdc_reg
rts


screenxy:	;calculate screen position into tmp1/2 from x/y
lda #$00
sta tmp2
tya
asl
rol tmp2
asl
rol tmp2
sta tmp
;tmp1/2 now = y*4
tya
clc
adc tmp
bcc +
inc tmp2
+ ; A / temp2 now = y*5
asl
rol tmp2
asl
rol tmp2
asl
rol tmp2
asl
rol tmp2
sta tmp	;tmp1/2 = y*5*16 = y*80
clc
txa
adc tmp
sta tmp
bcc +
inc tmp2	;tmp1/2 = y*80 + x
+ rts








; --- Variables

vblank:		!by $00
vblanktmp:	!by $00

backcycle:	!by $01
backcyclecount:	!by 50

smoothcount:	!by 1
smoothdefault:	!by 1

xsmooth:	!by $00
xsmoothdir	!by 0

ysmooth:	!by $00
ysmoothdir	!by 0




;    |---------01-3-5----0----5----0----5----0----5----0----5----0----5----01234567-|
prgtxt
!tx "blackdkgrydkblublue dkgrngreendkcyncyan dkred red dkpplpurplbrownyelowltgrywhite" ; 0
!tx "x128 vdc tester v0.1                                                   esc: exit" ; 1
!tx "--------------------------------------------------------------------------------" ; 2
!tx "a: attributes on/off     r: screen reverse on/off     crsr/home: move cursor    " ; 3
!tx "f: character flash rate  c: cursor mode               g: text/bitmap mode toggle" ; 4
!tx "b: background cycle on/off ('border' should match bckgrnd, except bitmap mode)  " ; 5
!tx "x: xsmooth test - left border should be fixed, right border 'open'              " ; 6
!tx "y: ysmooth test          : ; set background colour    + - adjust smooth speed   " ; 7
!tx "      v: show vblank area       i - interlace mode test                         " ; 8
!tx "                                                                                " ; 9



; end of errol's code ----------------------------------------------------


progsize = * - entry
